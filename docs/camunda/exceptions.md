Работа с проблемами и исключениями

В данном разделе мы рассмотрим различные аспекты работы с проблемами и исключениями в Camunda 8. Мы также рассмотрим различные стратегии обработки проблем и исключений на техническом и бизнес уровнях.
## Понимание воркеров

Сначала давайте кратко рассмотрим, как работает работник.

Когда экземпляр процесса поступает в задачу сервиса, создается новая задача и помещается во внутреннюю постоянную очередь в Camunda 8. Клиентское приложение может подписаться на эти задачи с помощью движка рабочих процессов по имени типа задачи (которое сопоставимо с именем очереди).

Если подписанный работник отсутствует, когда задача создается, задача просто помещается в очередь. Если подписано несколько работников, они являются конкурирующими потребителями, и задачи распределяются между ними.

![Концепция работника](dealing-with-problems-and-exceptions-assets/worker-concept.png)

Когда работник завершил все, что ему нужно сделать (например, вызвать REST-конечную точку), он отправляет еще один вызов в движок рабочих процессов, который [может быть одним из трех](/docs/components/concepts/job-workers/#completing-or-failing-jobs):

- [`CompleteJob`](/apis-tools/zeebe-api/gateway-service.md#completejob-rpc): Задача сервиса выполнена успешно, экземпляр процесса может двигаться дальше.
- [`FailJob`](/apis-tools/zeebe-api/gateway-service.md#failjob-rpc): Задача сервиса не выполнена, и движок рабочих процессов должен обработать эту ошибку. Существует две возможности:
  - `оставшиеся попытки > 0`: Задача повторяется.
  - `оставшиеся попытки <= 0`: Вызывается инцидент, и задача не повторяется до разрешения инцидента.
- [`ThrowError`](/apis-tools/zeebe-api/gateway-service.md#throwerror-rpc): Сообщается об ошибке BPMN, которая обычно обрабатывается на уровне BPMN.

Поскольку код-связка в работнике находится вне движка рабочих процессов, **техническая транзакция, охватывающая оба компонента, отсутствует**. Технические транзакции относятся к свойствам ACID (атомарность, согласованность, изоляция, долговечность), наиболее известным из реляционных баз данных.

Если, например, ваше приложение использует эти возможности, ваша бизнес-логика либо успешно фиксируется как целое, либо полностью откатывается в случае любой ошибки. Однако, эти транзакции ACID не могут быть применены к распределенным системам (об этом рассказывается в докладе [lost in transaction](https://berndruecker.io/lost-in-transaction/)). Другими словами, вещи могут выйти из синхронизации, если либо обработчик задач, либо движок рабочих процессов выходит из строя.

Типичный пример сценария следующий, где работник вызывает REST-конечную точку для вызова бизнес-логики:

![Типичная цепочка вызовов](dealing-with-problems-and-exceptions-assets/typical-call-chain.png)

Техническая транзакция ACID будет применяться только в бизнес-приложении. Работник задач в основном должен обрабатывать исключения на техническом уровне, например, для управления поведением повтора или передачи его на уровень процесса, где вам, возможно, потребуется реализовать бизнес-транзакции.


## Работа с проблемами на техническом уровне

### Использование повторных попыток

Важно понимать, что Camunda 8 использует стратегию **повторных попыток** для обработки ошибок. Это означает, что при возникновении ошибки процесс будет попытке выполнить задачу еще раз. Этот механизм называется **FailJob**.

```xml
    <bpmn:serviceTask id="TaskRetrieveMoney">
      <bpmn:extensionElements>
        <zeebe:taskDefinition retries="5" />
      </bpmn:extensionElements>
    </bpmn:serviceTask>
```


Пример использования `FailJob` в Java:

```java
@JobWorker(type = "retrieveMoney", autoComplete = false)
public void retrieveMoney(final JobClient client, final ActivatedJob job) {
    try {
        // ваш код
    } catch (Exception ex) {
        jobClient.newFailCommand(job)
          .retries(job.getRetries()-1) // <1>: Уменьшение количества повторных попыток
          .errorMessage("Не удалось получить деньги из-за: " + ex.getMessage()) // <2>
          .send()
          .exceptionally(t -> {throw new RuntimeException("Не удалось завершить задачу: " + t.getMessage(), t);});
    }
}
```

### Использование инцидентов

Когда задача завершается с количеством повторных попыток, равным 0, возникает **инцидент**. Инциденты требуют вручную обработки, обычно через приложение Operate. Подробнее о работе с инцидентами можно найти в [документации по операции](/docs/components/operate/userguide/resolve-incidents-update-variables/).

### Написание идентичных работников

Zeebe использует стратегию **повторных попыток** для обработки задач, что означает, что процесс может выполнить задачу не менее одного раза. Это называется **идентичностью работников**. Вам нужно учесть этот фактор в вашем коде, так как это может привести к нежелательным повторным выполнениям задач.

Один из способов решения этой проблемы - это написание **идентичных работников**. Это означает, что вы должны убедиться, что ваш код может определить, когда он уже выполнял задачу. Это может быть решено с помощью уникальных идентификаторов или хэшей. Например, вы можете добавить уникальный идентификатор в запрос и проверить его наличие в ответе. Если запрос уже был выполнен, вы сможете легко обнаружить это.

Пример использования идентичных работников в процессе моделирования:

<div bpmn="best-practices/dealing-with-problems-and-exceptions-assets/custom-idempotency-handling.bpmn" />

### Обработка ошибок на уровне процесса

Вы часто сталкиваетесь с отклонениями от "счастливого пути" (обычный сценарий с положительным результатом). Вам нужно учесть, как можно обработать эти отклонения в процессе моделирования.

### Использование BPMN-ошибок

Одним из способов обработать отклонения от "счастливого пути" является использование **BPMN-ошибок**. Это позволяет процессу реагировать на ошибки, которые возникают внутри задачи. Например:

<div bpmn="best-practices/dealing-with-problems-and-exceptions-assets/dealing-with-exception.bpmn" callouts="boundary_event_message_not_deliverable,user_task_send_invoice_to_customer"></div>

<span className="callout">1</span>

Мы решаем, что мы должны обработать ошибку, когда сообщение не может быть отправлено автоматически...

<span className="callout">2</span>

...мы назначаем человека, который теперь отвечает за отправку сообщения.

Подробнее о использовании **BPMN-ошибок** можно найти в [документации по моделированию BPMN](/docs/components/modeler/bpmn/error-events/).

### Использование BPMN-ошибок и ThrowError

В BPMN-процессах, мы можем явно моделировать ошибку, которая возникает внутри задачи.

<div bpmn="best-practices/dealing-with-problems-and-exceptions-assets/bpmn-error.bpmn" callouts="end_event_good_unavailable" />

<span className="callout">1</span>

В случае, когда товар недоступен, мы завершаем процесс с **BPMN-ошибкой**.

:::note
Вы можете имитировать **BPMN-ошибку** в вашем коде, используя `ThrowError` API. Последствия для процесса будут аналогичны, если бы это была явно моделированная **BPMN-ошибка**. Таким образом, вы можете имитировать **BPMN-ошибки** в вашем коде, используя `ThrowError` API.
:::

Пример использования `ThrowError` в Java:

```java
jobClient.newThrowErrorCommand(job)
   .errorCode("GOOD_UNAVAILABLE")
   .errorMessage()
   .send()
   .exceptionally(t -> {throw new RuntimeException("Не удалось завершить задачу: " + t.getMessage(), t);});
```

### Различение между ожидаемыми результатами и ошибками

Как правило, вы должны различать **ожидаемые результаты** от задач и **ошибки**, которые препятствуют достижению этих результатов.

Вам нужно понимать, что вы можете использовать **повторные попытки** для обработки ошибок, а также моделировать различные пути для обработки ожидаемых результатов.

Например, вы можете использовать **XOR-Gateway** для разделения путей, основанных на результатах задач. В случае, если результат задачи является неожиданным, вы можете использовать **Boundary-Event** для обработки этой ситуации.

<div bpmn="best-practices/dealing-with-problems-and-exceptions-assets/expected-results.bpmn" callouts="task_check_customers_creditworthiness,exclusive_gateway_customer_creditworthy,boundary_event_customer_id_non_existent" />

### Размышления о необработанных исключениях BPMN

Крайне важно понимать, что согласно спецификации BPMN, ошибка BPMN либо обрабатывается через процесс, либо **прекращает экземпляр процесса**. Это не приводит к возникновению инцидента. Следовательно, ошибку BPMN всегда можно и обычно следует обрабатывать. Конечно, вы также можете обработать ее в области родительского процесса, как в примере ниже:

<div bpmn="best-practices/dealing-with-problems-and-exceptions-assets/handling-a-bpmn-error.bpmn" callouts="boundary_event_good_unavailable" />

<span className="callout">1</span>

Граничное событие ошибки занимается случаем, когда товар недоступен.

### Бизнес-ошибки против технических ошибок

Обратите внимание, что теперь у вас есть два разных способа решения проблем:

- **Повторение**. Вы не хотите моделировать повторение, так как вам придется добавлять его к каждой задаче сервиса. Это сделает визуальную модель перегруженной и запутает бизнес-персонал. Вместо этого используйте либо повторение, либо переход к инцидентам, как описано выше. Это скрыто в визуальной части.
- Разветвление **отдельных путей**, как описано с событием ошибки.

В этом контексте мы обнаружили, что термины **бизнес-ошибка** и **техническая ошибка** могут быть путаницей, так как они слишком сильно акцентируют внимание на источнике ошибки. Это может привести к долгим дискуссиям о том, является ли определенная проблема технической или нет, и разрешено ли вам наблюдать технические ошибки в модели бизнес-процесса.

Гораздо важнее смотреть на то, как вы реагируете на определенные ошибки. Даже техническая проблема может квалифицироваться для бизнес-реакции. В приведенном выше примере, при технических проблемах с сервисом выставления счетов вы можете решить вручную отправить счет (бизнес-реакция) или пытаться повторить, пока сервис выставления счетов снова не станет доступен (техническая реакция).

Или, например, можно решить продолжить процесс в случае, если сервис оценки недоступен, и просто дать каждому клиенту хорошую оценку вместо того, чтобы блокировать прогресс. Ошибка явно техническая, но реакция является бизнес-решением.

В целом, рекомендуется говорить о бизнес-реакциях, которые моделируются в вашем процессе, и технических реакциях, которые обрабатываются обобщенно с использованием повторов или инцидентов.

## Принятие бизнес-транзакций и конечной согласованности

### Технические против бизнес-транзакций

Приложения, использующие базы данных, часто могут использовать возможности ACID (атомарность, согласованность, изоляция, долговечность) этих баз данных. Это означает, что некоторая бизнес-логика либо успешно фиксируется как целое, либо полностью откатывается в случае любой ошибки. Обычно это называется "транзакциями".

Эти транзакции ACID не могут быть применены к распределенным системам (об этом подробно рассказывается в докладе [lost in transaction](https://berndruecker.io/lost-in-transaction/)), поэтому, если вы обращаетесь к нескольким сервисам из процесса, вы сталкиваетесь с отдельными транзакциями ACID. Следующие иллюстрации взяты из книги O'Reilly [Practical Process Automation](https://processautomationbook.com/):

![Несколько транзакций ACID](dealing-with-problems-and-exceptions-assets/multiple-acid-transactions.png)

В приведенном выше примере система CRM и система выставления счетов имеют свои локальные транзакции ACID. Сам движок рабочих процессов также работает транзакционно. Однако, невозможно создать объединенную техническую транзакцию. Это требует нового способа обработки согласованности на бизнес-уровне, который называется **бизнес-транзакцией**:

![Бизнес против технической транзакции](dealing-with-problems-and-exceptions-assets/business-vs-technical-transaction.png)

**Бизнес-транзакция** отмечает секцию в процессе, для которой должна применяться семантика "все или ничего" (аналогично технической транзакции), но с бизнес-точки зрения. Вы можете столкнуться с несогласованными состояниями между ними (например, новый клиент уже присутствует в системе CRM, но еще не в системе выставления счетов).

### Конечная согласованность

Важно быть осведомленным о том, что такие временные несогласованности возможны. Также необходимо понимать сценарии сбоев, которые они могут вызвать. В приведенном выше примере, вы могли создать маркетинговую кампанию в момент, когда клиент уже был в системе CRM, но еще не в биллинге, поэтому он был включен в этот список. Затем, даже если его заказ будет отклонен и он никогда не станет активным клиентом, он все равно может получить рекламу об обновлении.

Необходимо понимать последствия этого. Кроме того, необходимо продумать стратегию устранения несогласованностей. Термин **конечная согласованность** предполагает, что необходимо предпринять меры для восстановления согласованного состояния в конечном итоге. В примере с онбордингом это может означать, что вам нужно деактивировать клиента в системе CRM, если его добавление в систему выставления счетов не удается. Это приводит к согласованному состоянию, при котором клиент не виден ни в одной системе.

### Бизнес-стратегии для управления несогласованностью

Существует три основные стратегии, если возникает проблема согласованности:

- Игнорировать. Хотя и кажется странным рассматривать возможность игнорирования проблемы согласованности, это на самом деле может быть действительной стратегией. Вопрос в том, какое бизнес-воздействие может иметь несогласованность.
- Извиниться. Это расширение стратегии игнорирования. Вы не пытаетесь предотвратить несогласованности, но вы убеждаетесь, что извиняетесь, когда их последствия становятся очевидными.
- Решить. Прямо столкнуться с проблемой и активно устранить несогласованность. Это может быть сделано различными способами, такими как упомянутые ранее задачи по приведению в соответствие, но эта практика сосредотачивается на том, как BPMN может помочь, рассматривая паттерн Saga.

Выбор правильной стратегии является четким бизнес-решением, поскольку ни одна из них не является правильной или неправильной, а просто более или менее подходящей для данной ситуации. Всегда следует думать о соотношении затрат/ценности.

### Паттерн Saga и компенсация BPMN

Паттерн Saga описывает долгосрочные транзакции в распределенных системах. Основная идея проста: когда вы не можете откатить задачи, вы отменяете их. (Название Saga отсылает к статье, написанной в 1980-х годах о долгосрочных транзакциях в базах данных.)

Camunda поддерживает это через события компенсации BPMN, которые могут связывать задачи с их задачами отмены.

<div bpmn="best-practices/dealing-with-problems-and-exceptions-assets/business-transaction.bpmn" callouts="add_customer,error_catch,throw_compensation,catch_compensation,deactivate_customer" />

<span className="callout">1</span>

Предположим, клиент уже был добавлен в систему CRM...

<span className="callout">2</span>

...когда произ