## Назначение микросервисов-воркеров

### Концепция

Реализуемая архитектура предполагает, что львиная доля бизнес-логики обеспечивается процессами, исполняемыми **Camunda BPM**. Микросервисы выполняют роль элементарных адаптеров к данным, сторонним сервисам или вычислительной логике. Цель такого подхода в том, чтобы вывести управление функциями системы из исходного кода в пользовательский интерфейс.

Для вызова микросервиса из BPM-процесса в диаграмму включается *сервисная задача* типа "внешняя задача" (Service Task - является стандартным компонентом **BPMN**, External Task – понятие Camunda) , в настройках которой прописываются необходимые параметры и переменные. После завершения выполнения задачи исполнение процесса возобновится

>
> Чем проще будет логика программного кода, тем больше придется реализовывать в бизнес-процессах
>

Простоты можно добиться не только снижением реализуемых микросервисами функций, но и определенными обобщениями и допущениями при работе с ними. Таким образом можно добиться почти одинаковости, *в плане того, как они лежат в руке*, двух совершенно разных инструментов. Выше было сказано, что микросервисы, суть, адаптеры к разного рода ресурсам. Мы можем абстрагироваться от реальной сути этих ресурсов и считать, что все они - сущности данных, а все многообразие манипуляций с ними свести (по крайней мере в разумных рамках, конечно) к CRUD-операциям. Но в качестве основы для нашего словаря методов, все же возьмем более гибкий словарь  REST.

> Стоит пояснить, что за этим стремлением к упрощению и обобщению стоит обыденное **loose coupling** - если частично спрятать бизнес-суть реальных объектов, меньше соблазнов будет их в какой то момент потом связать. Границы того, насколько возможно абстрагироваться в общем то и определяют **bounded context**.

**Итого**: у каждого сервиса есть как минимум одна сущность, над каждой сущностью можно производить как минимум один тип операции. Получаем такую нехитрую систему адресации задач:

```
[имя сервиса] [имя сущности] [операция]
```

**Имя сервиса** (service-id, application.name, etc.) в облачных системах - обязательный уникальный идентификатор.
Перечень **операций** ограничен и заранее определен. А вот с **сущностями** такой однозначности нет. Поэтому оптимально,
чтоб сущность у сервиса была одна (но без ущерба здравому смыслу).

### Топики

Упомянутый механизм вызова метода из BPMN реализован в Camunda в асинхронном режиме, что и позволяет применять его для оркестрации микросервисов. По этой же причине и терминологию они используют соответствующую: топик - идентифицируемое имя сервисной задачи бизнес-процесса, исполнители задач - *хэндлеры* - подписываются на задачи путем объявления подписки на топики.
Как несложно догадаться, у нас топиками являются операции с сущностями. 



Переиспользовать (ну или вдохновляться) для асинхронных операций предикаты REST запросов не только удобно, чтоб не
запутаться. Сервисы в любом случае будут иметь свой API и можно хотя бы на уровне персистентных процедур сэкономить в коде. Ну и руки нам никто тоже не связывает стандартами, чтобы подстроить словарь под себя.

> [!NOTE]
>
> Собачку в начале каждого метода я решил вставить, чтоб все же в смешанных контекстах различать одно от другого

#### @GET

Кроме классического `getById`, можно расширить до атрибутивного поиска (хоть до полнотекстового `find`), в том числе с
возвратом коллекции. При этом при пустом ответе можно выбрасывать ошибку

> [!TIP]
>
> В отличии от REST, где ошибка в одной операции обычно приводит к тому, что весь процесс прерывается, в BPM, как и в ООП, они служат инструментом управления потоком исполнения, поэтому зачастую лучше выкинуть `error` чем вернуть null

#### @PUT

Здесь тоже можно реализовать более интуитивное поведение - простой `create`, с ошибкой если нарушается уникальность

#### @PATCH

Здесь все как в оригинале

#### @HEAD

При текущей концепции удобно иметь отдельную операцию получения метаданных (схемы), хотя возможно не будет кейсов.

#### @STATE

Пока единственный *кастомный* метод, важный для нашей предметки - изменить статус.

> Это конечно просто предварительный список для обсуждения
